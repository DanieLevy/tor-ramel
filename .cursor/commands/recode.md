Deeply analyze the component to fully understand:

Functionality and all interactions

UI/UX and visual behavior

Inputs, outputs, props, events, and side effects

Dependencies on other components, hooks, or utilities

Identify any issues or weaknesses, such as:

Poor code structure or readability

Inefficient or duplicated logic

Bad handling of state, props, or events

Inconsistent coding patterns or styles

Recode the component:

Keep all UI/UX and functionality exactly as it is

Regenerate code with improved structure, readability, maintainability, and robustness

Refactor state management, event handling, and component logic for clarity and efficiency

Keep the public interface (props, handlers, exports) consistent so the component can replace the old one without breaking anything

Verify robustness: ensure the new component:

Maintains all previous behavior and visual layout

Works with all dependent components and hooks

Does not introduce errors, warnings, or side effects

After recoding, run lint to ensure no issues or warnings.

Provide the regenerated component code, ready to replace the old one, with clear comments explaining improvements and any key structural changes.

Constraints:

Focus only on the provided component and its dependencies.

Do not generate summaries or ask follow-up questions.

Do not change any functionality, UI, or UX.

The goal is a fully understood and recoded component that is cleaner, more robust, and maintainable, ready to replace the old one.